# 运算符

JavaScript 运算符用于赋值，比较值，执行算术运算等。

## 一元运算符

一元运算符只有一个参数，即要操作的对象或值。它们是 ECMAScript 中最简单的运算符。

### delete

delete 运算符删除对以前定义的对象属性或方法的引用。例如：

```javascript
var o = new Object;
o.name = "David";
console.log(o)  // {name: "David"}
delete o.name;
console.log(o)  // {}	
```

### void


void 运算符对任何值返回 undefined。该运算符通常用于避免输出不应该输出的值：

```javascript
var a = 1
console.log(void(a)) // undefined
```

### 前增量/前减量运算符

直接从 C（和 Java）借用的两个运算符是前增量运算符和前减量运算符。

```javascript
var iNum = 10;
++iNum;
console.log(iNum)  // 11
```
它实质上等价于：
```javascript
var iNum = 10;
iNum = iNum + 1；
```
同样，前减量运算符是从数值上减 1，形式是在变量前放两个减号（--）：
```javascript
var iNum = 10;
--iNum;
console.log(iNum) // 9
```

使用前缀式运算符时，注意增量和减量运算符都发生在计算表达式**之前**

```javascript
var iNum = 10;
var t = --iNum;
console.log(t)
```

在算术表达式中，前增量和前减量运算符的优先级是相同的，因此要按照从左到右的顺序计算之。例如：

```javascript
var iNum1 = 2;
var iNum2 = 20;
var iNum3 = --iNum1 + ++iNum2;	//等于 "22"
var iNum4 = iNum1 + iNum2;	
```

在前面的代码中，iNum3 等于 22，因为表达式要计算的是 1 + 21。变量 iNum4 也等于 22，也是 1 + 21。

### 后增量/后减量运算符

还有两个直接从 C（和 Java）借用的运算符，即后增量运算符和后减量运算符。

后增量运算符也是给数值上加 1，形式是在变量后放两个加号（++）：

```javascript
var iNum = 10;
iNum++;
```

不出所料，后减量运算符也是从数值上减 1，形式为在变量后加两个减号（--）

```javascript
var iNum = 10;
iNum--;
```

与前缀式运算符不同的是，后缀式运算符是在计算过包含它们的表达式后才进行增量或减量运算的。考虑以下的例子：

```javascript
var iNum = 10;
var t = iNum--;
console.log(t) // 10
console.log(iNum) // 9
```

在算术表达式中，后增量和后减量运算符的优先级是相同的，因此要按照从左到右的顺序计算之。例如：

```javascript
var iNum1 = 2;
var iNum2 = 20;
var iNum3 = iNum1-- + iNum2++;	//等于 "22"
var iNum4 = iNum1 + iNum2;		//等于 "22"
```

在前面的代码中，iNum3 等于 22，因为表达式要计算的是 2 + 20。变量 iNum4 也等于 22，不过它计算的是 1 + 21，因为增量和减量运算都在给 iNum3 赋值后才发生。

### 一元加法和一元减法

大多数人都熟悉一元加法和一元减法，它们在 ECMAScript 中的用法与您高中数学中学到的用法相同。

一元加法本质上对数字无任何影响

```javascript
var iNum = 20;
iNum = +iNum;
console.log(iNum);	// 20
```

尽管一元加法对数字无作用，但对字符串却有有趣的效果，会把字符串转换成数字。

```javascript
var sNum = "20";
console.log(typeof sNum);	//输出 "string"
var iNum = +sNum;
console.log(typeof iNum);	//输出 "number"
```

这段代码把字符串 "20" 转换成真正的数字。当一元加法运算符对字符串进行操作时，它计算字符串的方式与 parseInt() 相似，主要的不同是只有对以 "0x" 开头的字符串（表示十六进制数字），一元运算符才能把它转换成十进制的值。因此，用一元加法转换 "010"，得到的总是 10，而 "0xB" 将被转换成 11。

另一方面，一元减法就是对数值求负（例如把 20 转换成 -20）：

```javascript
var iNum = 20;
iNum = -iNum;
console.log(iNum);	//输出 "-20"
```

与一元加法运算符相似，一元减法运算符也会把字符串转换成近似的数字，此外还会对该值求负。

```javascript
var sNum = "20";
console.log(typeof sNum);	//输出 "string"
var iNum = -sNum;
console.log(iNum);		//输出 "-20"
console.log(typeof iNum);	//输出 "number"
```

## 位运算符

位运算符是在数字底层（即表示数字的 32 个数位）进行操作的。


我们首先了解下数是如何在计算机中存储的。

### 整数的表示


ECMAScript 整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）。在 ECMAScript 中，所有整数字面量默认都是有符号整数，这意味着什么呢？
有符号整数使用 31 位表示整数的数值，用第 32 位表示整数的符号，0 表示正数，1 表示负数。数值范围从 -2147483648 到 2147483647。
可以以两种不同的方式存储二进制形式的有符号整数，一种用于存储正数，一种用于存储负数。正数是以真二进制形式存储的，前 31 位中的每一位都表示 2 的幂，从第 1 位（位 0）开始，表示 20，第 2 位（位 1）表示 21。没用到的位用 0 填充，即忽略不计。例如，下图展示的是数 18 的表示法。

![](http://www.w3school.com.cn/i/ct_js_integer_binary_signed_32bits.gif)

18 的二进制版本只用了前 5 位，它们是这个数字的有效位。把数字转换成二进制字符串，就能看到有效位：

```javascript
var iNum = 18;
console.log(iNum.toString(2));  // "10010"
```
这段代码只输出 "10010"，而不是 18 的 32 位表示。其他的数位并不重要，因为仅使用前 5 位即可确定这个十进制数值。如下图所示：

![](http://www.w3school.com.cn/i/ct_js_integer_binary_number18.gif)

负数也存储为二进制代码，不过采用的形式是二进制补码。计算数字二进制补码的步骤有三步：

1. 确定该数字的非负版本的二进制表示（例如，要计算 -18的二进制补码，首先要确定 18 的二进制表示）
2. 求得二进制反码，即要把 0 替换为 1，把 1 替换为 0
3. 在二进制反码上加 1

要确定 -18 的二进制表示，首先必须得到 18 的二进制表示，如下所示：

```
0000 0000 0000 0000 0000 0000 0001 0010
```

接下来，计算二进制反码，如下所示：

```
1111 1111 1111 1111 1111 1111 1110 1101
```

最后，在二进制反码上加 1，如下所示：

```
1111 1111 1111 1111 1111 1111 1110 1101
                                      1
---------------------------------------
1111 1111 1111 1111 1111 1111 1110 1110
```

因此，-18 的二进制表示即 1111 1111 1111 1111 1111 1111 1110 1110

记住，在处理有符号整数时，开发者不能访问 31 位。因为第 31 位是符号位。


### 位运算 NOT


位运算 NOT 由否定号（~）表示，它是 ECMAScript 中为数不多的与二进制算术有关的运算符之一。

位运算 NOT 是三步的处理过程：

1. 把运算数转换成 32 位数字
2. 把二进制数转换成它的二进制反码
3. 把二进制数转换成浮点数

```javascript
var iNum1 = 25;		//25 等于 00000000000000000000000000011001
var iNum2 = ~iNum1;	//转换为 11111111111111111111111111100110
console.log(iNum2);		//输出 "-26"
```

### 位运算 AND

位运算 AND 由和号（&）表示，直接对数字的二进制形式进行运算。它把每个数字中的数位对齐，然后用下面的规则对同一位置上的两个数位进行 AND 运算：

|第一个数字中的数位|第二个数字中的数位|	结果|
|:---|:---|:----|
|1	|1	|1|
|1	|0	|0|
|0	|1	|0|
|0	|0	|0|

要对数字 25 和 3 进行 AND 运算，代码如下所示：

```javascript
var iResult = 25 & 3;
console.log(iResult);	//输出 "1"
```

25 和 3 进行 AND 运算的结果是 1。为什么？分析如下：

```javascript
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001
```

可以看出，在 25 和 3 中，只有一个数位（位 0）存放的都是 1，因此，其他数位生成的都是 0，所以结果为 1。

### 位运算 OR

位运算 OR 由符号（|）表示，也是直接对数字的二进制形式进行运算。在计算每位时，OR 运算符采用下列规则：

|第一个数字中的数位|	第二个数字中的数位|	结果|
|:---|:---|:----|
|1	|1|	1|
|1	|0|	1|
|0	|1|	1|
|0	|0|	0|

对 25 和 3 进行 OR 运算，代码如下：


```javascript
var iResult = 25 | 3;
console.log(iResult);	//输出 "27"
```

25 和 3 进行 OR 运算的结果是 27：

```javascript
25 = 0000 0000 0000 0000 0000 0000 0001 1001
 3 = 0000 0000 0000 0000 0000 0000 0000 0011
--------------------------------------------
OR = 0000 0000 0000 0000 0000 0000 0001 1011
```

可以看出，在两个数字中，共有 4 个数位存放的是 1，这些数位被传递给结果。二进制代码 11011 等于 27。


### 位运算 XOR

位运算 XOR 由符号（^）表示，当然，也是直接对二进制形式进行运算。XOR 不同于 OR，当只有一个数位存放的是 1 时，它才返回 1。真值表如下：

|第一个数字中的数位|	第二个数字中的数位|	结果|
|1	|1|	0|
|1	|0|	1|
|0	|1|	1|
|0	|0|	0|

对 25 和 3 进行 XOR 运算，代码如下：

```javascript
var iResult = 25 ^ 3;
console.log(iResult);	//输出 "26"
```

25 和 3 进行 XOR 运算的结果是 26：

```
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
XOR = 0000 0000 0000 0000 0000 0000 0001 1010
```

### 左移运算

左移运算由两个小于号表示（<<）。它把数字中的所有数位向左移动指定的数量。例如，把数字 2（等于二进制中的 10）左移 5 位，结果为 64（等于二进制中的 1000000）：


```javascript
var iOld = 2;		//等于二进制 10
var iNew = iOld << 5;	//等于二进制 1000000 十进制 64
```

可以看出，在两个数字中，共有 4 个数位存放的是 1，这些数位被传递给结果。二进制代码 11010 等于 26。

在左移数位时，数字右边多出 5 个空位。左移运算用 0 填充这些空位，使结果成为完整的 32 位数字。

![](http://www.w3school.com.cn/i/ct_js_operators_bitwise_leftshift.gif)

左移运算保留数字的符号位。例如，如果把 -2 左移 5 位，得到的是 -64，而不是 64。“符号仍然存储在第 32 位中吗？”是的，不过这在 ECMAScript 后台进行，开发者不能直接访问第 32 个数位。即使输出二进制字符串形式的负数，显示的也是负号形式（例如，-2 将显示 -10。）

### 有符号右移运算

有符号右移运算符由两个大于号表示（>>）。它把 32 位数字中的所有数位整体右移，同时保留该数的符号（正号或负号）。有符号右移运算符恰好与左移运算相反。例如，把 64 右移 5 位，将变为 2：

```javascript
var iOld = 64;		//等于二进制 1000000
var iNew = iOld >> 5;	//等于二进制 10 十进制 2
```

同样，移动数位后会造成空位。这次，空位位于数字的左侧，但位于符号位之后。ECMAScript 用符号位的值填充这些空位，创建完整的数字，如下图所示：

![](http://www.w3school.com.cn/i/ct_js_operators_bitwise_signedrightshift.gif)

### 无符号右移运算


无符号右移运算符由三个大于号（>>>）表示，它将无符号 32 位数的所有数位整体右移。对于正数，无符号右移运算的结果与有符号右移运算一样。

用有符号右移运算中的例子，把 64 右移 5 位，将变为 2：

```javascript
var iOld = 64;		//等于二进制 1000000
var iNew = iOld >>> 5;	//等于二进制 10 十进制 2
```
对于负数，情况就不同了。

无符号右移运算用 0 填充所有空位。对于正数，这与有符号右移运算的操作一样，而负数则被作为正数来处理。

由于无符号右移运算的结果是一个 32 位的正数，所以负数的无符号右移运算得到的总是一个非常大的数字。例如，如果把 -64 右移 5 位，将得到 134217726。如何得到这种结果的呢？

要实现这一点，需要把这个数字转换成无符号的等价形式（尽管该数字本身还是有符号的），可以通过以下代码获得这种形式：

```javascript
var iUnsigned64 = -64 >>> 0;
```

然后，用 Number 类型的 toString() 获取它的真正的位表示，采用的基为 2：

```javascript
alert(iUnsigned64.toString(2));
```

这将生成 11111111111111111111111111000000，即有符号整数 -64 的二进制补码表示，不过它等于无符号整数 4294967232。
出于这种原因，使用无符号右移运算符要小心。


未完待续
